## 1. state 선언은 어디에?

해당 state를 사용하는 컴포넌트들을 잘 구분해놓은 뒤 그 컴포넌트들 중 가장 최상위 컴포넌트에 선언

만약 그 state를 사용하는 최상위 컴포넌트보다 더 상위 컴포넌트에 state를 선언하면 state를 사용하지 않는 더 많은 컴포넌트들이 state변경에 의해 불필요한 리렌더링을 겪게 된다.

## 2. 객체 타입의 state는 최대한 분할하여 선언

객체가 크고 복잡한 형태일수록 최대한 분할하여 선언하는 것이 좋다.

만약 복잡한 객체로 선언된 state를 분할하지 않으면, 하위 컴포넌트가 사용하지 않은 다른 객체 프로퍼티 값이 변경될 때도 리렌더링이 발생한다.

## 3. hooks에서 shouldComponentUpdate를 대체하는 방법

- shouldComponentUpdate
    <aside>
    ➡️ 클래스형 컴포넌트에서 리렌더링 여부를 결정하는 로직을 만드는 생명주기 메소드
    렌더링 최적화를 위해 자주 쓰이던 메소드
    
    </aside>


함수형 컴포넌트에서는 React.memo를 사용하여 구현한다.

## 4. React.memo를 이용한 컴포넌트 메모이제이션 방법

컴포넌트가 `React.memo`로 래핑 될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징한다. 그리고 다음 렌더링일 일어날 때 `props`를 비교하여 같다면 메모이징 된 내용을 재사용한다.

메모이징 한 결과를 재사용 함으로써, React에서 리렌더링을 할 때 가상 DOM에서 달라진 부분을 확인하지 않아 성능상의 이점을 누릴 수 있다.

메모이제이션의 성능상 이점을 측정하기 위해 [profilling](https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab)을 사용한다.

콜백함수를 이용해 메모이제이션을 적용할지 여부를 판단할 수 있다.

- 언제 `React.memo`를 써야할까?
    <aside>
    ➡️ 같은 `props`로 렌더링이 자주 일어나는 컴포넌트
    
    일반적으로 부모 컴포넌트에 의해 하위 컴포넌트가 같은 props로 리렌더링 될 때가 있다.
    
    </aside>

- 언제 `React.memo` 를 사용하지 말아야할까?
    <aside>
    ➡️ 쓸모없는 `props` 비교
    렌더링 될 때 `props`가 다른 경우가 대부분인 컴포넌트를 생각해보면, 메모이제이션의 이점을 얻기 힘들다.
    
    </aside>
    
    props 가 자주 변하는 컴포넌트를 래핑할지라도, React는 두 작업을 리렌더링 할 때마다 수행한다.
    
    1. 이전 `props`와 다음 `props`의 동등 비교를 위해 비교 함수 실행
    2. 비교 함수는 `false`를 반환할 것이기 때문에, React는 이전 렌더링 내용과 다음 렌더링 내용을 비교할 것이다.
        
         → 결국 props 비교 불필요
